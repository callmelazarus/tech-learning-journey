#!/usr/bin/env python3
"""
generate_data.py
Reads all .md files from ../knowledge/ and writes frontend/data.js
Run from the frontend/ directory: python3 generate_data.py
"""

import json
import os
from pathlib import Path

KNOWLEDGE_DIR = Path(__file__).parent.parent / "knowledge"
OUTPUT_FILE = Path(__file__).parent / "data.js"

# Override titles for common slugs that need better formatting
TITLE_OVERRIDES = {
    "swe": "Software Engineering",
    "ai": "Artificial Intelligence",
    "ml": "Machine Learning",
    "misc": "Miscellaneous",
    "aws-cloud": "AWS Cloud",
    "javascript": "JavaScript",
    "typescript": "TypeScript",
    "nlp-classic": "NLP (Classic)",
    "data_structures_algos": "Data Structures & Algorithms",
    "map-filter-reduce": "Map / Filter / Reduce",
    "mcp-protocol": "MCP Protocol",
    "llms": "LLMs",
    "mlops": "MLOps",
    "devops": "DevOps",
    "backend": "Backend",
    "frontend": "Frontend",
    "react": "React",
    "redux": "Redux",
    "autheNtication": "Authentication",
    "sql": "SQL",
    "drizzle": "Drizzle ORM",
    "db_indexing": "DB Indexing",
    "npm-dependency-tree": "NPM Dependency Tree",
    "time-space-complexity": "Time & Space Complexity",
    "business-value": "Business Value",
    "design-patterns": "Design Patterns",
    "data-engineering": "Data Engineering",
}


def slug_to_title(slug: str) -> str:
    if slug in TITLE_OVERRIDES:
        return TITLE_OVERRIDES[slug]
    return slug.replace("-", " ").replace("_", " ").title()


def extract_title(content: str, fallback: str) -> str:
    for line in content.splitlines():
        line = line.strip()
        if line.startswith("# "):
            return line[2:].strip()
    return slug_to_title(fallback)


def build_nav_tree(articles: list) -> list:
    """Build a nested navigation tree from flat article list."""
    root: dict = {}

    for article in articles:
        parts = article["path"]
        node = root

        # Walk all parts except the leaf
        for i, part in enumerate(parts[:-1]):
            if part not in node:
                node[part] = {"__children__": {}, "__id__": "/".join(parts[: i + 1])}
            node = node[part]["__children__"]

        # Insert the leaf
        leaf = parts[-1]
        node[leaf] = {
            "__leaf__": True,
            "__id__": article["id"],
            "__title__": article["title"],
        }

    return dict_to_tree(root, depth=0)


def dict_to_tree(d: dict, depth: int) -> list:
    result = []
    for key in sorted(d.keys()):
        val = d[key]
        if val.get("__leaf__"):
            result.append(
                {
                    "key": key,
                    "title": val["__title__"],
                    "id": val["__id__"],
                    "is_leaf": True,
                    "depth": depth,
                }
            )
        else:
            children = dict_to_tree(val.get("__children__", {}), depth + 1)
            node_id = val.get("__id__", key)
            result.append(
                {
                    "key": key,
                    "title": slug_to_title(key),
                    "id": node_id,
                    "is_leaf": False,
                    "depth": depth,
                    "children": children,
                }
            )
    return result


def count_leaves(node: dict) -> int:
    if node.get("is_leaf"):
        return 1
    return sum(count_leaves(c) for c in node.get("children", []))


def main():
    print(f"Scanning {KNOWLEDGE_DIR} ...")

    md_files = sorted(
        f
        for f in KNOWLEDGE_DIR.rglob("*.md")
        if f.name != "INDEX.md" and not f.name.startswith(".")
    )

    articles = []
    for filepath in md_files:
        rel = filepath.relative_to(KNOWLEDGE_DIR)
        path_parts = list(rel.parent.parts) + [filepath.stem]
        article_id = "/".join(path_parts)
        content = filepath.read_text(encoding="utf-8", errors="replace")
        title = extract_title(content, filepath.stem)
        articles.append(
            {
                "id": article_id,
                "title": title,
                "path": path_parts,
                "content": content,
            }
        )

    print(f"Found {len(articles)} articles")

    nav_tree = build_nav_tree(articles)

    data = {
        "navTree": nav_tree,
        "articles": articles,
    }

    js = (
        "// Auto-generated by generate_data.py â€” do not edit manually\n"
        f"const LEARNINGS = {json.dumps(data, ensure_ascii=False, indent=2)};\n"
    )

    OUTPUT_FILE.write_text(js, encoding="utf-8")
    size_kb = OUTPUT_FILE.stat().st_size // 1024
    print(f"Written to {OUTPUT_FILE} ({size_kb} KB, {len(articles)} articles)")


if __name__ == "__main__":
    main()
